name: Container CI with Docker

on:
  workflow_call:
    inputs:
      project_name:
        type: string
        required: true
      docker_context:
        type: string
        required: false
        default: .
      dockerfile_path:
        type: string
        required: false
        default: Dockerfile
      docker_target:
        type: string
        required: false
        default: ""
      docker_build_args:
        type: string
        required: false
        default: ""
      docker_tag_suffix:
        type: string
        required: false
        default: ""
      scan_severity_cutoff:
        type: string
        required: false
        default: critical
      scan_fail_build:
        type: boolean
        required: false
        default: true
    secrets:
      aws_access_key_id:
        required: true
      aws_secret_access_key:
        required: true
    outputs:
      image_tag:
        value: ${{ jobs.build.outputs.image_tag }}

env:
  AWS_REGION: us-east-1

permissions:
  id-token: write
  contents: read

jobs:
  lint:
      name: lint
      runs-on: live
      if: ${{ (github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'synchronize')) || (github.event_name == 'push' && (github.ref_type == 'tag' || inputs.docker_tag_suffix != '')) }}
      steps:
        - name: checkout
          uses: actions/checkout@v3
  
        - name: lint dockerfile
          uses: hadolint/hadolint-action@v3.0.0
          continue-on-error: true
          with:
            dockerfile: ${{ inputs.dockerfile_path }}

  build:
    name: build
    runs-on: live
    needs:
      - lint
    if: ${{ (github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'synchronize')) || (github.event_name == 'push' && (github.ref_type == 'tag' || inputs.docker_tag_suffix != '')) }}
    steps:
      - name: checkout
        uses: actions/checkout@v3

      - name: get namespace
        id: get_namespace
        run: |          
          NAMESPACE=$(ls charts)
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Download Application Artifact
        uses: RocketBus/actions/.github/actions/utils/s3-artifact-download@acme-3879
        continue-on-error: true
        with:
          name: ${{ steps.get_namespace.outputs.namespace }}-${{ github.run_id }}
          bucket_region: ${{ vars.ARTIFACTS_BUCKET_REGION }}
          bucket_name: ${{ vars.ARTIFACTS_BUCKET_NAME }}
          actions_iam_role: ${{ vars.ACTIONS_IAM_ROLE }}

      - name: unzip tar.gz artifact
        run: |
          if test -f "app-artifact.tar.gz"; then
            tar -xzf ./app-artifact.tar.gz
            rm -f ./app-artifact.tar.gz
          fi

      - name: setup Docker context for Buildx
        id: buildx-context
        run: docker context create builders

      - name: setup Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
        with:
          endpoint: builders

      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          aws-access-key-id: ${{ secrets.aws_access_key_id }}
          aws-secret-access-key: ${{ secrets.aws_secret_access_key }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: false

      - name: login to Amazon ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: docker metadata
        id: docker_metadata
        uses: docker/metadata-action@v4
        with:
          images: ${{ steps.login_ecr.outputs.registry }}/${{ inputs.project_name }}
          tags: |
            type=ref,event=pr,prefix=pr-,suffix=-{{sha}}
            type=semver,pattern={{version}},suffix=${{ inputs.docker_tag_suffix }}
            type=raw,value=${{ inputs.docker_tag_suffix }}

      - name: set image properties
        id: image_properties
        run: |
          IMAGE_REPOSITORY=${{ inputs.project_name }}
          IMAGE_TAGS=(${{ steps.docker_metadata.outputs.tags }})
          FIRST_IMAGE_TAG=${IMAGE_TAGS[0]}
          IMAGE_TAG=${FIRST_IMAGE_TAG##*:}

          echo "image_repository=$IMAGE_REPOSITORY" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image=$FIRST_IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: setup ECR repository
        run: |
          aws ecr describe-repositories \
            --repository-names ${{ steps.image_properties.outputs.image_repository }} 2> /dev/null || \
          aws ecr create-repository \
            --repository-name ${{ steps.image_properties.outputs.image_repository }} \
            --image-scanning-configuration scanOnPush=true 

          aws ecr set-repository-policy \
            --repository-name ${{ steps.image_properties.outputs.image_repository }} \
            --policy-text '
              {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Sid": "AllowPull",
                    "Action": [
                      "ecr:GetAuthorizationToken",
                      "ecr:BatchCheckLayerAvailability",
                      "ecr:GetDownloadUrlForLayer",
                      "ecr:GetRepositoryPolicy",
                      "ecr:DescribeRepositories",
                      "ecr:ListImages",
                      "ecr:DescribeImages",
                      "ecr:BatchGetImage",
                      "ecr:GetLifecyclePolicy",
                      "ecr:GetLifecyclePolicyPreview",
                      "ecr:ListTagsForResource",
                      "ecr:DescribeImageScanFindings"
                    ],
                    "Effect": "Allow",
                    "Principal": {
                      "AWS": [
                        "arn:aws:iam::180811438061:root",
                        "arn:aws:iam::406026015868:root",
                        "arn:aws:iam::114395709799:root"
                      ]
                    }
                  }
                ]
              }
            '

      - name: docker build
        uses: docker/build-push-action@v3
        with:
          cache-from: type=gha
          cache-to: type=gha,mode=max
          context: ${{ inputs.docker_context }}
          file: ${{ inputs.dockerfile_path }}
          target: ${{ inputs.docker_target }}
          build-args: ${{ inputs.docker_build_args }}
          labels: ${{ steps.docker_metadata.outputs.labels }}
          tags: ${{ steps.image_properties.outputs.image }}
          outputs: type=docker,dest=/tmp/${{ steps.image_properties.outputs.image_repository }}.tar.gz

      - name: docker push
        run: |
          echo "Pushing image to ECR..."
          docker load -i /tmp/${{ steps.image_properties.outputs.image_repository }}.tar.gz
          docker push ${{ steps.image_properties.outputs.image }}
    outputs:
      image_repository: ${{ steps.image_properties.outputs.image_repository }}
      image_tag: ${{ steps.image_properties.outputs.image_tag }}

  image_scan:
    name: image scan
    runs-on: live
    needs:
      - lint
      - build
    steps:
      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          aws-access-key-id: ${{ secrets.aws_access_key_id }}
          aws-secret-access-key: ${{ secrets.aws_secret_access_key }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: false

      - name: login to Amazon ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: check image scan finds
        run: |
          IMAGE_REPOSITORY=${{ needs.build.outputs.image_repository }}
          IMAGE_TAG=${{ needs.build.outputs.image_tag }}

          aws ecr wait image-scan-complete --repository-name $IMAGE_REPOSITORY --image-id imageTag=$IMAGE_TAG

          if [[ $? -eq 0 ]]; then
            SEVERITY_CUTOFF=${{ inputs.scan_severity_cutoff }}
            SEVERITY_CUTOFF=${SEVERITY_CUTOFF^^}

            SCAN_FINDINGS=$(aws ecr describe-image-scan-findings --repository-name $IMAGE_REPOSITORY --image-id imageTag=$IMAGE_TAG --query imageScanFindings.findingSeverityCounts)

            case $SEVERITY_CUTOFF in
              CRITICAL)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.CRITICAL, .HIGH, .MEDIUM, .LOW, .INFORMATIONAL, .UNDEFINED] | add')
              ;;
              HIGH)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.HIGH, .MEDIUM, .LOW, .INFORMATIONAL, .UNDEFINED] | add')
              ;;
              MEDIUM)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.MEDIUM, .LOW, .INFORMATIONAL, .UNDEFINED] | add')
              ;;
              LOW)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.LOW, .INFORMATIONAL, .UNDEFINED] | add')
              ;;
              INFORMATIONAL)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.INFORMATIONAL, .UNDEFINED] | add')
              ;;
              UNDEFINED)
                SCAN_FINDINGS_COUNT=$(echo $SCAN_FINDINGS | jq -r '[.UNDEFINED] | add')
              ;;
            esac

            echo "## Vulnerability summary :shield:" >> $GITHUB_STEP_SUMMARY
            aws ecr describe-image-scan-findings --repository-name $IMAGE_REPOSITORY --image-id imageTag=$IMAGE_TAG --query "imageScanFindings.findings[].{Name: name, Severity: severity, Package: join(':', [attributes[?key=='package_name'].value | join('', @), attributes[?key=='package_version'].value | join('', @)])}" --output table | sed s/'+'/'|'/g | tail -n +4 | head -n -1 >> $GITHUB_STEP_SUMMARY

            if [[ $SCAN_FINDINGS_COUNT -gt 0 ]]; then
              if ${{ inputs.scan_fail_build }}; then
                # aws ecr batch-delete-image --repository-name $IMAGE_REPOSITORY --image-ids imageTag=$IMAGE_TAG
                echo "::error title=image scan::Failed minimum severity level. Found vulnerabilities with level ${SEVERITY_CUTOFF,,} or higher"
                # exit 1
              else
                echo "::warning title=image scan::Warning minimum severity level. Found vulnerabilities with level ${SEVERITY_CUTOFF,,} or higher"
              fi
            fi
          fi
